
    
<title>File uploader</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script>
    hljs.highlightAll();
</script>
<style>
    .page__section form {
        margin-bottom: 20px;
    }

    .page__section form h1 {
        margin-bottom: 10px;
        font-size: 20px;
    }

    .page__section form input[type="submit"] {
        width: 100%;
        padding: 10px;
        border: none;
        border-radius: 5px;
        background-color: #007bff;
        color: #fff;
        cursor: pointer;
    }

    .page__section form input[type="submit"]:hover {
        background-color: #0056b3;
    }

    code {
        text-align: left;
        display: block;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #f9f9f9;
    }

    

    form {
        margin-top: 30px;
    }

    h1 {
        margin-top: 30px;
    }

   
</style>

<main class="page__main">
    <article class="page__article">
        <header class="page__article-header">
            <h1 class="page__article-header-text">
                File Uploader
            </h1>
        </header>

        <section class="page__section page__section--center">

            <h1>Niezabezpieczony file uploader</h1>
            <p>
            File uploader jest krytycznym punktem aplikacji, a jego nieodpowiednie zabezpieczonie
            może doprowadzić do poważnych konsekwencji, jak przeciążenie systemu plików, 
            a nawet przejęcie systemu. 
</p>
<p>
            W niezabezpieczonej wersji właściwości plików, 
            takie jak typ lub rozmiar, nie są rzetelnie sprawdzane. Przykład niewystarczającego
            zabezpieczenia stanowi poniższy kod.
            </p>

           
           
            <code>
               
            &lt input type="file" name="fileToUpload" id = "fileToUpload" accept="image/*" &gt
            </code>
            
            <p>
            Podjęto próbę ograniczenia typu przesyłanych plików, za pomocą atrybutu "accept".
            Aby obejść to zabezpieczenie wystarczy skorzystać z narzędzia DevTools i usunąć ten fragment kodu HTML, 
            a następnie przesłać plik niebędący obrazem. Co więcej, nie został ograniczony maksymalny rozmiar pliku, 
            zatem atakujący móglby spróbować obciążyć serwer wieloma plikami o dużym rozmiarze.
            </p>
            
            <p>
            Przykład file uploadera, którego jedne zabezpieczenie stanowi atrybut HTML znajduje się poniżej.
</p>



            <form action="/vulnerability-vault/file-uploader/upload" method="POST"  enctype="multipart/form-data">
                <input type="file" name="fileToUpload" id = "fileToUpload" accept="image/*">
                <input type="submit" name="unsafe_submit" value="submit">
            </form>
            

            <h1>Zabezpieczony file uploader</h1>

            <p>
            Aby uniknąć ingerencji użytkownika w zabezpieczenia systemu, nie należy umieszczać ich w sekcji dostępnej 
            dla użytkownika za pomocą narzędzi deweloperskich. Poniżej przedstawione zabezpieczenia wykonywane są po stronie serwera.
            </p>
            <p>Pierwszym krokiem jest sprawdzenie typu przesyłanego pliku. W przykładowym kodzie poniżej celem
                jest upewnienie się, że plik jest obrazem.
            </p>

                <pre>
                        <code class="language-php">  
$correct = 0;
@$check_error = getimagesize($_FILES["fileToUpload"]["tmp_name"]);

// Checking if an actual image
if( $check_error!== false) {
// Image
    $correct = 1;
} else {
// Not an image
    $correct = 0;
}

// Check the extension
$imageFileType = strtolower(pathinfo($target_file,PATHINFO_EXTENSION));
$uploaded_type = $_FILES[ 'fileToUpload' ][ 'type' ];

if($imageFileType != "jpg" && $imageFileType != "png" && $imageFileType != "jpeg"
        && $imageFileType != "gif" && ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' )) {
//Wrong extension
        $correct = 0;
}
                </code></pre>
            
                <p>Funkcja getimagesize() sprawdza typ MIME przesyłanego pliku i zwraca wartość false, jeśli nie 
                    jest on typem obrazu. Funkcja pathinfo() umożliwia uzyskanie informacji o ścieżce pliku, a następnie
                    wyłuskanie informacji o rozszerzeniu w celu porównania z dozwolonymi rozszerzeniami obrazów. 
</p>
<p>
                    W celu pozbycia się metadanych, wówczas można na nowo zakodować obraz
                    za pomocą funkcji imagecreateformjpg() lub imagecreatefrompng(). </p>
                    <pre>
                        <code class="language-php">              
if( $uploaded_type == 'image/jpeg' ) {
	$img = imagecreatefromjpeg( $uploaded_tmp );
    imagejpeg( $img, $temp_file, 100);
}
else {
	$img = imagecreatefrompng( $uploaded_tmp );
	imagepng( $img, $temp_file, 9);
}
imagedestroy( $img );
</code></pre>

                <p>Kolejnym krokiem jest sprawdzenie, czy rozmiar pliku mieści się w określonych granicach. Poza maksymalnym rozmiarem 
                warto jest sprawdzić, czy rozmiar nie jest równy 0 bajtów. Niezabezpieczony system może pozwalić użytkownikowi przesałać dowolną 
                liczbę plików 0-bajtowych, ponieważ ich rozmiar nawet po zsumowaniu nie przekroczy żadnej ustalonej granicy. 
                Jest to jednak ryzykowne, ponieważ pomimo zerowego rozmiaru, przechowywanie takich plików wciąż zajmuje pewną ilość pamięci związaną w tym wypadku 
                nie z danymi (zawartością pliku), ale metadanymi (właściwościami samych plików, np. ich nazwami).
                </p>
                <pre><code class = "language-php">
// Check the size
if ($_FILES["fileToUpload"]["size"] > 100000  or $_FILES["fileToUpload"]["size"] == 0 ) {
    //Too large
$correct = 0;
}
</code></pre>

<p>Zaprezentowana poniżej poprawiona wersja file uploadera spełnia wszystkie opisane powyżej wymagania, 
    co czyni ją znacznie bezpieczniejszym rozwiązaniem.
</p>

            <form action="/vulnerability-vault/file-uploader/upload" method="POST"  enctype="multipart/form-data">
                <input type="file" name="fileToUpload" id = "fileToUpload" accept="image/*">
                <input type="submit" name="safe_submit" value="submit">
            </form>

            <?php PathService::prevNextButton('/command-injection', '/xss-reflected', 'Command Injection', 'XSS Reflected'); ?>
        </section>
    </article>
</main>